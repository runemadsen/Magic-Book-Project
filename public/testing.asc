Chapter 2.  Forces
------------------

[quote]
“Don't underestimate the Force.”
  —Darth Vader

In the final example of Chapter 1, we saw how we could calculate a dynamic acceleration based on a vector pointing from a circle on the screen to the mouse location.   The resulting motion resembled a magnetic attraction between circle and mouse, as if some _force_ were pulling the circle in towards the mouse.  In this chapter we will formalize our understanding of the concept of a *_force_* and its relationship to *_acceleration_*.    Our goal, by the end of this chapter, is to understand how to make multiple objects move around the screen and respond to a variety of environmental forces.

=== Section Heading

In the text, there are words that can be styled uniformly, i.e. every time a [var]*variable* appears like [var]*x* or [var]*velocity*.  Also, sometimes I refer to functions like [function]*setup()* and [function]*draw()* as well as classes, like [klass]*PVector* or [klass]*Particle*.  And sometimes I just include some code inline, like, this is how you say would update the velocity: [mono]*velocity.add(acceleration);*.

==== Subsection heading 1

some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah

==== Subsection heading 2

some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah some text blah blah

=== Some Highlighted Text

Newton’s first law is commonly stated as:

[NOTE]
=====================================================================
_An object at rest stays at rest and an object in motion stays in motion._
=====================================================================

However, this is missing an important element related to forces and so we could expand it by stating:

[NOTE]
=====================================================================
_An object at rest stays at rest and an object in motion stays in motion at a constant speed and direction unless acted upon by an unbalanced force._
=====================================================================

=== 2.1 Examples of Tables

.A table with code in it.
|=======================
|1. A function that receives both an [klass]*Attractor* and a [klass]*Mover*:  |attraction(a,m);
|2. A function in the [klass]*Attractor* class that receives a [klass]*Mover*:   |a.attract(m);
|3. A function in the [klass]*Mover* class that receives an [klass]*Attractor*:  |m.attractedTo(a);
|4. A function in the [klass]*Attractor* class that receives a [klass]*Mover* and returns a [klass]*PVector*, which is the attraction force.  That attraction force is then passed into the [klass]*Mover*’s [function]*applyForce()* function:  |PVector f = a.attract(m);
m.applyForce(f);
|=======================

.A tiny table with two columns of numbers
[options="header"]
|=======================
|Time	|Noise Value
|0	    |0.365
|1	    |0.363
|2	    |0.363
|3	    |0.364
|4	    |0.366
|=======================

=== 2.1 Exercises

.Exercise 3.1
==================
Rotate a baton-like object (see below) around its center using [function]*translate()* and [function]*rotate()*.

image::imgs/chapter03/chapter03_exc01.png[canvas="processingjs/chapter03/Ex_3_01_exercise_baton/Ex_3_01_exercise_baton.pde"]
==================

.Exercise 2.8
==================
In the example above, we have a system (i.e. array) of Mover objects and one Attractor object.  Build an example that has both systems of Movers and Attractors.  What if you make the Attractors invisible?  Can you create a pattern / design from the trails of objects moving around attractors?  (See the Metropop Denim project by Clayton Cubitt and Tom Carden: http://processing.org/exhibition/works/metropop/) for an example.) 
==================

=== 2.3 Examples

image::imgs/chapter02/ch2_ex08.png[canvas="processingjs/chapter02/_2_8_mutual_attraction/_2_8_mutual_attraction.pde processingjs/chapter02/_2_8_mutual_attraction/Mover.pde",classname="screenshot"]

[[chapter02_example8]]
[example]*Example 2.8: Mutual Attraction*

[source,java]
----
Mover[] movers = new Mover[20];

float g = 0.4;

void setup() {
  size(400,400);
  for (int i = 0; i < movers.length; i++) {
    movers[i] = new Mover(random(0.1,2),random(width),random(height)); 
  }
}

void draw() {
  background(255);

  for (int i = 0; i < movers.length; i++) {
    for (int j = 0; j < movers.length; j++) {
      // Don’t attract yourself!
      if (i != j) {           
        PVector force = movers[j].attract(movers[i]);
        movers[i].applyForce(force);
      }
    }
    movers[i].update();
    movers[i].display();
  }
}
----

=== 2.4 Breakout boxes

Acceleration is directly proportional to force and inversely proportional to mass.  This means that if you get pushed, the harder you are pushed, the faster you’ll move (accelerate).  The bigger you are, the slower you’ll move.

[NOTE]
.Weight vs. Mass
=====================================================================
- The *mass* of an object is a measure of the amount of matter in the object (measured in kilograms).
- *Weight*, though often mistaken for mass, is technically the force of gravity on an object. From Newton’s second law, we can calculate it as mass times the acceleration of gravity ([var]*w* = [var]*m* * [var]*g*). Weight is measured in newtons.
- *Density* is is defined as the amount of mass per unit of volume (grams per cubic centimeter, for example).

Note that an object that has a mass of one kilogram on earth would have a mass of one kilogram on the moon. However, it would weigh only one-sixth as much.
=====================================================================

Now, in the world of Processing, what is mass anyway?  Aren’t we dealing with pixels?  To start in a simpler place, let’s say that in our pretend pixel world, all of our objects have a mass equal to 1.  [var]*F*/ 1 = [var]*F*.  And so:

=== 2.2 Examples of Lists

Following is an exmaple of a bulleted list where the items are all one line width. To me it seems like these should be tightly packed vertically?

[classname="packed"]
- _chance of moving up: 	20%_
- _chance of moving down: 	20%_
- _chance of moving left: 	20%_
- _chance of moving right: 	40%_

Here's a numbered list where the elements are one line paragraphs.

. Pick a random number: R1
. Compute a probability P that R1 should qualify.  Let’s try: P = R1.
. Pick another random number: R2
. If R2 is less than P, then we have found our number—R1!
. If R2 is not less than P, go back to step 1 and start over.

Here's a numbered list with paragraph elements.  These can have line breaks between them?

- *An autonomous agent has a _limited_ ability to perceive environment.*   It makes sense that a living, breathing being should have an awareness of its environment.  What does this mean for us, however?   As we look at examples in this chapter, we will point out programming techniques for allowing objects to store references to other objects and therefore “perceive” their environment.    It’s also crucial that we consider the word *_limited_* here.  Are we designing an all-knowing rectangle that flies around a Processing window, aware of everything else in that window?  Or are we creating a shape that can only examine any other object within fifteen pixels of itself?   Of course, there is no right answer to this question; it all depends.  We’ll explore some possibilities as we move forward.  For a simulation to feel more “natural,” however, limitations are a good thing.  An insect, for example, may only be aware of the sights and smells that immediately surround it.   For a real-world creature, we could study the exact science of these limitations.   Luckily for us, we can just make stuff up and try it out.

- *An autonomous agent processes the information from its environment and calculates an action.*    This will be the easy part for us, as the action is a force.  The environment might tell the agent that there’s a big scary-looking shark swimming right at it, and the action will be a powerful force in the opposite direction.  

- *An autonomous agent has no leader.*  This third principle is something we care a little less about.  After all, if you are designing a system where it makes sense to have a leader barking commands at various entities, then that’s what you’ll want to implement.  Nevertheless, many of these examples will have no leader for an important reason.   As we get to the end of this chapter and examine group behaviors, we will look at designing collections of autonomous agents that exhibit the properties of complex systems— intelligent and structured group dynamics that emerge not from a leader, but from the local interactions of the elements themselves.

=== 2.3 End of Chapter Project

[TIP]
.The Ecosystem Project:
==================
Step 2 Exercise:

Incorporate the concept of forces into your ecosystem.   Try introducing other elements into the environment (food, a predator) that the creature interacts with.   Does the creature experience attraction or repulsion to things in its world?  Can you think more abstractly and design forces based on the creature’s desires or goals?
==================
