<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<articleinfo>
    <title>Chapter 1.  Vectors</title>
</articleinfo>
<blockquote>
<simpara>“Roger, Roger. What&#8217;s our vector, Victor?”
        —Captain Oveur, Airplane</simpara>
</blockquote>
<simpara>This book is all about looking at the world around us and coming up with clever ways to simulate that world with code.  Divided into three parts, the book will start by looking at basic physics—how an apple falls from a tree, a pendulum swings in the air, the earth revolves around the sun, etc.  Absolutely everything contained within the first five chapters of this book requires the use of the most basic building block for programming motion—the <emphasis role="strong"><emphasis>vector</emphasis></emphasis>.   And so this is where we begin our story.</simpara>
<simpara>Now, the word <emphasis role="strong"><emphasis>vector</emphasis></emphasis> can mean a lot of different things. Vector is the name of a new wave rock band formed in Sacramento, CA in the early 1980s.  It’s the name of a breakfast cereal manufactured by Kellogg’s Canada.   In the field of epidemiology, a vector is used to describe an organism that transmits infection from one host to another.  In the C++ programming language, a Vector (std::vector) is an implementation of a dynamically resizable array data structure.  While all these definitions are interesting, they’re not what we are looking for.   What we want is called a <emphasis role="strong">Euclidean vector</emphasis> (named for the Greek mathematician Euclid and also known as a geometric vector).  When you see the term “vector” in this book, you can assume it refers to a Euclidean vector defined as:</simpara>
<simpara><emphasis role="strong"><emphasis>A vector is an entity that has both magnitude and direction.</emphasis></emphasis></simpara>
<simpara>A vector is typically drawn as a arrow; the direction is indicated by where the arrow is pointing, and the magnitude by the length of the arrow itself.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_1-01.png" classname="half-width" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_1-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><phrase role="notetoself">REDO THIS DIAGRAM NOW TO FIT NEW DEFINITION</phrase></emphasis></simpara>
<simpara>In the diagram above, the vector is drawn as an arrow from point A to point B and serves as an instruction for how to travel from A to B.</simpara>
<section id="_1_1_vectors_you_complete_me">
<title>1.1 Vectors, You Complete Me</title>
<simpara>Before we dive into more of the details about vectors, let’s look at a basic Processing example that demonstrates why we should care about vectors in the first place.  If you’ve read any of the introductory Processing textbooks or taken a class on programming with Processing (and hopefully you’ve done one of these things to help prepare you for this book), you probably, at one point or another, learned to how to write a simple bouncing ball sketch.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_2-01.png" canvas="processingjs/bouncingball_novectors.pde" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_2-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<section id="_example_1_1_bouncing_ball_with_no_vectors">
<title>Example 1.1: Bouncing ball with no vectors</title>
<programlisting language="java" linenumbering="unnumbered">// Variables for location and speed of ball.
float x = 100;
float y = 100;
float xspeed = 1;
float yspeed = 3.3;

// Remember how Processing works?  setup() is executed once when the sketch starts and draw() loops forever and ever (until you quit).
void setup() {
  size(200,200);
  smooth();
  background(255);
}

void draw() {
  background(255);

  // Move the ball according to its speed.
  x = x + xspeed;
  y = y + yspeed;

  // Check for bouncing
  if ((x &gt; width) || (x &lt; 0)) {
    xspeed = xspeed * -1;
  }
  if ((y &gt; height) || (y &lt; 0)) {
    yspeed = yspeed * -1;
  }

  stroke(0);
  fill(175);
  // Display the ball at the location x,y.
  ellipse(x,y,16,16);
}</programlisting>
<simpara>In the above example, we have a very simple world—a blank canvas with a circular shape (a “ball”) traveling around.  This ball has some properties, which are represented in the code as variables.</simpara>
<literallayout class="monospaced">*_LOCATION:_* *_x and y_*
*_SPEED:_*    *_xspeed and yspeed_*</literallayout>
<simpara>In a more advanced sketch, we could imagine having many more variables:</simpara>
<literallayout class="monospaced">*_ACCELERATION:_*     *_xacceleration and yacceleration_*
*_TARGET LOCATION:_*  *_xtarget and ytarget_*
*_WIND:_*             *_xwind and ywind_*
*_FRICTION:_*         *_xfriction and yfriction_*</literallayout>
<simpara>It’s becoming more and more clear that for every concept in this world (wind, location, acceleration, etc.), we need two variables.  And this is only a two-dimensional world. In a 3D world, we’ll need <emphasis role="strong"><phrase role="var">x</phrase></emphasis>, <emphasis role="strong"><phrase role="var">y</phrase></emphasis>, <emphasis role="strong"><phrase role="var">z</phrase></emphasis>, <emphasis role="strong"><phrase role="var">xspeed</phrase></emphasis>, <emphasis role="strong"><phrase role="var">yspeed</phrase></emphasis>, <emphasis role="strong"><phrase role="var">zspeed</phrase></emphasis>, and so on.</simpara>
<simpara>Wouldn’t it be nice if we could simplify our code and use fewer variables?</simpara>
<simpara>Instead of:</simpara>
<programlisting language="java" linenumbering="unnumbered">float x;
float y;
float xspeed;
float yspeed;</programlisting>
<simpara>Wouldn’t it be nice to have. . .</simpara>
<programlisting language="java" linenumbering="unnumbered">Vector location;
Vector speed;</programlisting>
<simpara>Taking this first step in using vectors won’t allow us to do anything new.  Just adding vectors won’t magically make your Processing sketches simulate physics; however, they will simplify your code and provide a set of functions for common mathematical operations that happen over and over and over again while programming motion.</simpara>
<simpara>As an introduction to vectors, we’re going to live in two dimensions for quite some time (at least until we get through the first several chapters.)  All of these examples can be fairly easily extended to three dimensions (and the class we will use—[class]*PVector*—allows for three dimensions.)  However, for the time being, it’s easier to start with just two.</simpara>
</section>
</section>
<section id="_1_2_vectors_what_are_they_to_us_processing_programmers">
<title>1.2 Vectors: What are they to us Processing programmers?</title>
<simpara>One way to think of a vector is the difference between two points.   Consider how you might go about providing instructions to walk from one point to another.</simpara>
<simpara>Here are some vectors and possible translations:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_3-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_3-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>(  3, 5) —&gt; Walk three steps east, turn and walk five steps north.
(  2,-1) —&gt; Walk two steps east, turn and walk one step south.
(-15, 3) —&gt; Walk fifteen steps west, turn and walk three steps north.</simpara>
<simpara>You’ve probably done this before when programming motion.  For every frame of animation (i.e.  a single cycle through Processing’s <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis> loop), you instruct each object on the screen to move a certain number of pixels horizontally and a certain number of pixels vertically.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_4-01.png" classname="half-width" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_4-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For every frame:</simpara>
<simpara><emphasis role="strong"><emphasis>new location = velocity applied to current location</emphasis></emphasis></simpara>
<simpara>If velocity is a vector (the difference between two points), what is location?   Is it a vector too?  Technically, one might argue that location is not a vector, since it’s not describing how to move from one point to another—it’s simply describing a singular point in space.  And so conceptually, we think of a location as different.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_5-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_5-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong"><phrase role="notetoself">CONSIDER COMBINING / INTEGRATING THIS DIAGRAM WITH PREVIOUS ONE BETTER</phrase></emphasis></simpara>
<simpara>Nevertheless, another way to describe a location is the path taken from the origin to reach that location. Hence, a location can be the vector representing the difference between location and origin.</simpara>
<simpara>Let’s examine the underlying data for both location and velocity.  In the bouncing ball example we had the following:</simpara>
<simpara>location —&gt; <emphasis role="strong"><phrase role="var">x</phrase></emphasis>,<emphasis role="strong"><phrase role="var">y
velocity —&gt; [var]*xspeed</phrase></emphasis>,<emphasis role="strong"><phrase role="var">yspeed</phrase></emphasis></simpara>
<simpara>Notice how we are storing the _same data for both_—two floating point numbers, an x and a y. If we were to write a vector class ourselves, we’d start with something rather basic:</simpara>
<programlisting language="java" linenumbering="unnumbered">class PVector {

  float x;
  float y;

  PVector(float x_, float y_) {
    x = x_;
    y = y_;
  }

}</programlisting>
<simpara>At its core, a <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> is just a convenient way to store two values (or three, as we’ll see in 3D examples.).</simpara>
<simpara>And so this. . .</simpara>
<programlisting language="java" linenumbering="unnumbered">float x = 100;
float y = 100;
float xspeed = 1;
float yspeed = 3.3;</programlisting>
<orderedlist numeration="arabic">
<listitem>
<simpara>
. . becomes . . .
</simpara>
</listitem>
</orderedlist>
<programlisting language="java" linenumbering="unnumbered">PVector location = new PVector(100,100);
PVector velocity = new PVector(1,3.3);</programlisting>
<simpara>Now that we have two vector objects (“location” and “velocity”), we’re ready to implement the algorithm for motion—location = location + velocity.   In Example 1.1, without vectors, we had:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Add each speed to each location.
x = x + xspeed;
y = y + yspeed;</programlisting>
<simpara>In an ideal world, we would be able to rewrite the above as:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Add the velocity vector to the location vector.
[line-through]*location = location + velocity;*</programlisting>
<simpara>However, in Processing, the addition operator ‘+’ is reserved for primitive values (integers, floats, etc.) only.  Processing doesn’t know how to add two <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> objects together any more than it knows how to add two <emphasis role="strong"><emphasis>PFont</emphasis></emphasis> objects or <emphasis role="strong"><emphasis>PImage</emphasis></emphasis> objects.   Fortunately for us, the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class includes functions for common mathematical operations.</simpara>
</section>
<section id="_1_3_vector_addition">
<title>1.3 Vector Addition</title>
<simpara>Before we continue looking at the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class and its <emphasis role="strong"><phrase role="function">add()</phrase></emphasis> method (purely for the sake of learning since it’s already implemented for us in Processing itself), let’s examine vector addition using the notation found in math and physics textbooks</simpara>
<simpara>Vectors are typically written either in boldface type or with an arrow on top.  For the purposes of this book, to distinguish a <emphasis role="strong"><emphasis>vector</emphasis></emphasis> from a <emphasis role="strong">scalar</emphasis> (scalar refers to a single value, such as an integer or a floating point number), we’ll use the arrow notation:</simpara>
<simpara>Vector: <emphasis role="strong"><phrase role="vector">u*￼
Scalar: [var]*x</phrase></emphasis></simpara>
<simpara>Let’s say I have the following two vectors:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_6-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_6-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Each vector has two components, an x and a y.  To add two vectors together we simply add both x’s and both y’s.  In other words:</simpara>
<literallayout class="monospaced">[vector]*w* = Vector: [vector]*u* + Vector: [vector]*v*</literallayout>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_7-01.png" classname="half-width-right" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_7-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>translates to:</simpara>
<literallayout class="monospaced">[vector]*w*~x~ = [var]*u~x~* + [var]*v~x~*
[vector]*w*~y~ = [var]*u~y~* + [var]*v~y~*</literallayout>
<simpara>and therefore:</simpara>
<literallayout class="monospaced">[vector]*w*~x~ =  5 + 3
[vector]*w*~y~ =  2 + 4</literallayout>
<simpara>and therefore:</simpara>
<literallayout class="monospaced">[vector]*w* =  (8,6)</literallayout>
<simpara>Now that we understand how to add two vectors together, we can look at how addition is implemented in the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class itself.    Let’s write a function called <emphasis role="strong"><phrase role="function">add()</phrase></emphasis> that takes as its argument another <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> object.</simpara>
<programlisting language="java" linenumbering="unnumbered">class PVector {

  float x;
  float y;

  PVector(float x_, float y_) {
    x = x_;
    y = y_;
  }

  *// New!  A function to add another PVector to this PVector.  Simply add the x components and the y components together.
  void add(PVector v) {
    x = x + v.x;
    y = y + v.y;
  }*
}</programlisting>
<simpara>Now that we see how <emphasis role="strong"><phrase role="function">add()</phrase></emphasis> is written inside of <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>, we can return to the <emphasis role="strong"><emphasis>location + velocity</emphasis></emphasis> algorithm with our bouncing ball example and implement vector addition:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Add the current velocity to the location.
[line-through]*location = location + velocity;*
location.add(velocity);</programlisting>
<simpara>And here we are, ready to rewrite the bouncing ball example using <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>.</simpara>
<section id="_example_1_2_bouncing_ball_with_pvector">
<title>Example 1.2: Bouncing ball with PVector!</title>
<programlisting language="java" linenumbering="unnumbered">// Instead of a bunch of floats, we now just have two PVector variables.
*_PVector location;_*
*_PVector velocity;_*

void setup() {
  size(200,200);
  smooth();
  *_location = new PVector(100,100);_*
  *_velocity = new PVector(2.5,5);_*
}

void draw() {
  background(255);

  *_location.add(velocity);

  // We still sometimes need to refer to the individual components of a PVector and can do so using the dot syntax: location.x, velocity.y, etc.
  if ((location.x &gt; width) || (location.x &lt; 0)) {
    velocity.x = velocity.x * -1;
  }
  if ((location.y &gt; height) || (location.y &lt; 0)) {
    velocity.y = velocity.y * -1;
  }_*

  stroke(0);
  fill(175);
  *_ellipse(location.x,location.y,16,16);_*
}</programlisting>
<simpara>Now, you might feel somewhat disappointed.  After all, this may initially appear to have made the code more complicated than the original version.  While this is a perfectly reasonable and valid critique, it’s important to understand that we haven’t fully realized the power of programming with vectors just yet.   Looking at a simple bouncing ball and only implementing vector addition is just the first step.  As we move forward into a more complex world of multiple objects and multiple <emphasis role="strong"><emphasis>forces</emphasis></emphasis> (Chapter 2), the benefits of <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> will become more apparent.</simpara>
<simpara>We should, however, make note of an important aspect of the above transition to programming with vectors.  Even though we are using <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> objects to describe two values—the x and y of location and the x and y of velocity—we still often need to refer to the x and y components of each <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> individually.  When we go to draw an object in Processing, there’s no means for us to say:</simpara>
<programlisting language="java" linenumbering="unnumbered">[line-through]*ellipse(location,16,16);*</programlisting>
<simpara>The <emphasis role="strong"><phrase role="function">ellipse()</phrase></emphasis> function does not allow for a <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> as an argument.  An ellipse can only be drawn with two scalar values, an x coordinate and a y coordinate.  And so we must dig into the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> object and pull out the x and y components using object-oriented dot syntax.</simpara>
<programlisting language="java" linenumbering="unnumbered">ellipse(location.x,location.y,16,16);</programlisting>
<simpara>The same issue arises when testing if the circle has reached the edge of the window, and we need to access the individual components of both vectors: location and velocity.</simpara>
<programlisting language="java" linenumbering="unnumbered">if ((location.x &gt; width) || (location.x &lt; 0)) {
  velocity.x = velocity.x * -1;
}</programlisting>
<example>
<title>Exercise 1.1</title>
<simpara>Find something you’ve previously made in Processing using separate <emphasis role="strong"><phrase role="var">x</phrase></emphasis> and <emphasis role="strong"><phrase role="var">y</phrase></emphasis> variables and use PVectors instead.</simpara>
</example>
<example>
<title>Exercise 1.2</title>
<simpara>Take any of the walker examples from the introduction and convert it to use PVectors.</simpara>
</example>
<example>
<title>Exercise 1.3</title>
<simpara>Extend the bouncing ball with vectors example into 3D.  Can you get a sphere to bounce around a box?</simpara>
</example>
</section>
</section>
<section id="_1_4_more_vector_math">
<title>1.4 More Vector Math</title>
<simpara>Addition was really just the first step.   There are many mathematical operations that are commonly used with vectors.   Below is a comprehensive list of the operations available as functions in the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class.  We’ll go through a few of the key ones now.  As our examples get more and more sophisticated in later chapters, we’ll continue to reveal the details of more functions.</simpara>
<itemizedlist>
<listitem>
<simpara>
[function]*add()*—add vectors
</simpara>
</listitem>
<listitem>
<simpara>
[function]*sub()*—subtract vectors
</simpara>
</listitem>
<listitem>
<simpara>
[function]*mult()*—scale the vector with multiplication
</simpara>
</listitem>
<listitem>
<simpara>
[function]*div()*—scale the vector with division
</simpara>
</listitem>
<listitem>
<simpara>
[function]*mag()*—calculate the magnitude of a vector
</simpara>
</listitem>
<listitem>
<simpara>
[function]*normalize()*—normalize the vector to unit length of 1
</simpara>
</listitem>
<listitem>
<simpara>
[function]*limit()*—limit the magnitude of a vector
</simpara>
</listitem>
<listitem>
<simpara>
[function]*heading2D()*—the heading of a vector expressed as an angle
</simpara>
</listitem>
<listitem>
<simpara>
[function]*rotate()*—rotate a 2D vector by an angle
</simpara>
</listitem>
<listitem>
<simpara>
[function]*dist()*—the Euclidean distance between two vectors (considered as points)
</simpara>
</listitem>
<listitem>
<simpara>
[function]*angleBetween()*—find the angle between two vectors
</simpara>
</listitem>
<listitem>
<simpara>
[function]*dot()*—the dot product of two vectors
</simpara>
</listitem>
<listitem>
<simpara>
[function]*cross()*—the cross product of two vectors (only relevant in three dimensions)
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><phrase role="note to self">[CHECK WHAT NEW ONES I’M ADDING IN 2.0]</phrase></emphasis>
</simpara>
</listitem>
</itemizedlist>
<simpara>Having already covered addition, let’s start with subtraction.  This one’s not so bad; just take the plus sign and replace it with a minus!</simpara>
<simpara><emphasis role="strong"><emphasis>Vector subtraction:</emphasis></emphasis>   <emphasis role="strong"><phrase role="vector">w</phrase></emphasis>=<emphasis role="strong"><phrase role="vector">u</phrase></emphasis> - <emphasis role="strong"><phrase role="vector">v</phrase></emphasis></simpara>
<simpara>translates to:    <emphasis role="strong"><phrase role="vector">w</phrase></emphasis><subscript>x</subscript> = u<subscript>x</subscript> - v<subscript>x</subscript>
                  <emphasis role="strong"><phrase role="vector">w</phrase></emphasis><subscript>y</subscript> = u<subscript>y</subscript> - v<subscript>y</subscript></simpara>
<simpara>and the function inside <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> therefore looks like:</simpara>
<programlisting language="java" linenumbering="unnumbered">void sub(PVector v) {
    x = x - v.x;
    y = y - v.y;
  }</programlisting>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_8-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_8-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The following example demonstrates vector subtraction by taking the difference between two points—the mouse location and the center of the window.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_9-01.png" canvas="processingjs/vector_subtraction/vector_subtraction.pde" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_9-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<section id="_example_1_3_vector_subtraction">
<title>Example 1-3: Vector subtraction</title>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  size(200,200);
  smooth();
}

void draw() {
  background(255);

  // Two PVectors, one for the mouse location and one for the center of the window.
  PVector mouse  = new PVector(mouseX,mouseY);
  PVector center = new PVector(width/2,height/2);

  // PVector subtraction!
  mouse.sub(center);

  // Draw a line to represent the vector.
  translate(width/2,height/2);
  line(0,0,mouse.x,mouse.y);

}</programlisting>
<example>
<title>Need Heading</title>
<simpara>Both addition and subtraction with vectors follow the same algebraic rules as with real numbers.</simpara>
<simpara><emphasis role="strong"><emphasis>The commutative rule:</emphasis></emphasis>   <emphasis role="strong"><phrase role="vector">u</phrase></emphasis> + <emphasis role="strong"><phrase role="vector">v*￼ = [vector]*v</phrase></emphasis> + [vector]*u*￼</simpara>
<simpara><emphasis role="strong"><emphasis>The associative rule:</emphasis></emphasis> ￼[vector]<emphasis role="strong">u</emphasis> + (<emphasis role="strong"><phrase role="vector">v</phrase></emphasis> + <emphasis role="strong"><phrase role="vector">w</phrase></emphasis>)  = (￼[vector]<emphasis role="strong">u</emphasis> + <emphasis role="strong"><phrase role="vector">v</phrase></emphasis>) + [vector]*w*￼</simpara>
<simpara>Fancy terminology and symbols aside, this is really quite a simple concept.  We’re just saying that common sense properties of addition apply to vectors as well.</simpara>
<literallayout class="monospaced">*_3 + 2 = 2 + 3_*</literallayout>
<literallayout class="monospaced">*_(3 + 2) + 1 = 3 + (2 + 1)_*</literallayout>
</example>
<simpara>Moving on to multiplication, we have to think a little bit differently.  When we talk about multiplying a vector, what we typically mean is <emphasis role="strong"><emphasis>scaling</emphasis></emphasis> a vector.  In the case that we want to scale a vector to twice its size or one-third of its size (leaving its direction the same), we would say: “Multiply the vector by 2” or “Multiply the vector by 1/3.”   Note we are multiplying a vector by a scalar, a single number, not another vector.</simpara>
<simpara>To scale a vector, we multiply each component (x and y) by a scalar.</simpara>
<simpara><emphasis role="strong"><emphasis>Vector multiplication:</emphasis></emphasis>    <emphasis role="strong"><phrase role="vector">w</phrase></emphasis> = <emphasis role="strong"><phrase role="vector">u</phrase></emphasis> * n</simpara>
<simpara>translates to:    w<subscript>x</subscript> = u<subscript>x</subscript> * n
                  w<subscript>y</subscript> = u<subscript>y</subscript> * n</simpara>
<simpara>Let’s look at an example with vector notation.</simpara>
<literallayout class="monospaced">[vector]*u* = (-3,7)
n = 3</literallayout>
<literallayout class="monospaced">[vector]*w* = [vector]*u* * n
w~x~ = -3 * 3
w~y~ =  7 * 3</literallayout>
<literallayout class="monospaced">[vector]*w* = (-9, 21)</literallayout>
<simpara>The function inside the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class therefore is written as:</simpara>
<programlisting language="java" linenumbering="unnumbered">// With multiplication, the components of the vector are multiplied by a number.
void mult(float n) {
   x = x * n;
   y = y * n;
 }</programlisting>
<simpara>And implementing multiplication in code is as simple as:</simpara>
<programlisting language="java" linenumbering="unnumbered">// This PVector is now three times the size and is equal to (-9,21).
PVector u = new PVector(-3,7);
u.mult(3);</programlisting>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_11-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_11-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section id="_example_1_4_multiplying_a_vector">
<title>Example 1-4: Multiplying a vector</title>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  size(200,200);
  smooth();
}

void draw() {
  background(255);

  PVector mouse = new PVector(mouseX,mouseY);
  PVector center = new PVector(width/2,height/2);
  mouse.sub(center);

  // Multiplying a vector!  The vector is now half its original size (multiplied by 0.5).
  mouse.mult(0.5);

  translate(width/2,height/2);
  line(0,0,mouse.x,mouse.y);

}</programlisting>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_12-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_12-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Division works just like multiplication—we simply replace the multiplication sign (asterisk) with the division one (forward slash).</simpara>
<programlisting language="java" linenumbering="unnumbered">void div(float n) {
  x = x / n;
  y = y / n;
}

PVector u = new PVector(8,-4);
u.div(2);</programlisting>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_13-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_13-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>.</simpara>
<informalexample>
<simpara>As with addition, basic algebraic rules of multiplication and division apply to vectors.</simpara>
<simpara>The associative rule:   (<emphasis role="strong"><phrase role="var">n</phrase></emphasis> * <emphasis role="strong"><phrase role="var">m</phrase></emphasis>) <emphasis role="strong">￼[vector]*v</emphasis> = <emphasis role="strong"><phrase role="var">n</phrase></emphasis> * (<emphasis role="strong"><phrase role="var">m</phrase></emphasis> <emphasis role="strong">￼[vector]*v</emphasis>)
The distributive rule with 2 scalars, 1 vector:   (<emphasis role="strong"><phrase role="var">n</phrase></emphasis> * <emphasis role="strong"><phrase role="var">m</phrase></emphasis>) <emphasis role="strong">￼[vector]*v</emphasis> = <emphasis role="strong"><phrase role="var">n</phrase></emphasis> * <emphasis role="strong"><phrase role="vector">v</phrase></emphasis> + <emphasis role="strong"><phrase role="var">m</phrase></emphasis> <emphasis role="strong">￼[vector]*v</emphasis>
The distributive rule with 2 vectors, 1 scalar:   (<emphasis role="strong"><phrase role="vector">u*￼+ [vector]*v</phrase></emphasis>) * <emphasis role="strong"><phrase role="var">n</phrase></emphasis> = <emphasis role="strong"><phrase role="var">n</phrase></emphasis> * <emphasis role="strong"><phrase role="vector">u</phrase></emphasis> + <emphasis role="strong"><phrase role="var">n</phrase></emphasis> * [vector]*v*￼</simpara>
</informalexample>
</section>
</section>
<section id="_1_5_vector_magnitude">
<title>1.5 Vector Magnitude</title>
<simpara>Multiplication and division, as we just saw, are means by which the length of the vector can be changed without affecting direction.  Perhaps you’re wondering: “OK, so how do I know what the length of a vector is?  I know the components (<emphasis role="strong"><phrase role="var">x</phrase></emphasis> and <emphasis role="strong"><phrase role="var">y</phrase></emphasis>), but how long (in pixels) is the actual arrow?!”</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_14-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_14-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>.</simpara>
<informalexample>
<simpara>The length or “magnitude” of a vector <emphasis role="strong"><phrase role="vector">v</phrase></emphasis> is often written as: ||￼[vector]<emphasis role="strong">v</emphasis> ||</simpara>
</informalexample>
<simpara>Understanding how to calculate the length (also known as <emphasis role="strong"><emphasis>magnitude</emphasis></emphasis>) of a vector is incredibly useful and important.</simpara>
<simpara>Notice in the above diagram how the vector, drawn as an arrow and two components (<emphasis role="strong"><phrase role="var">x</phrase></emphasis> and <emphasis role="strong"><phrase role="var">y</phrase></emphasis>), creates a right triangle.  The sides are the components and the hypotenuse is the arrow itself.   We’re very lucky to have this right triangle, because once upon a time, a Greek mathematician named Pythagoras developed a lovely formula to describe the relationship between the sides and hypotenuse of a right triangle.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_15-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_15-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The Pythagorean theorem: <emphasis role="strong"><phrase role="var">a</phrase></emphasis> squared plus <emphasis role="strong"><phrase role="var">b</phrase></emphasis> squared equals <emphasis role="strong"><phrase role="var">c</phrase></emphasis> squared.</simpara>
<simpara>Armed with this formula, we can now compute the magnitude of <emphasis role="strong"><phrase role="vector">v</phrase></emphasis> as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>
|| <emphasis role="strong"><phrase role="vector">v</phrase></emphasis> || = <emphasis role="strong"><emphasis>sqrt (v<subscript>x</subscript> * v<subscript>x</subscript> + v<subscript>y</subscript> * v<subscript>y</subscript>)</emphasis></emphasis>
</simpara>
</listitem>
</itemizedlist>
<simpara>or in <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">float mag() {
  return sqrt(x*x + y*y);
}</programlisting>
<section id="_example_1_5_vector_magnitude">
<title>Example 1-5: Vector magnitude</title>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_15-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_15-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered">void setup() {
  size(200,200);
  smooth();
}

void draw() {
  background(255);

  PVector mouse = new PVector(mouseX,mouseY);
  PVector center = new PVector(width/2,height/2);
  mouse.sub(center);

  // The magnitude (i.e. length) of a vector can be accessed via the mag() function.  Here it is used as the width of a rectangle drawn at the top of the window.
  float m = mouse.mag();
  fill(0);
  rect(0,0,m,10);

  translate(width/2,height/2);
  line(0,0,mouse.x,mouse.y);

}</programlisting>
</section>
</section>
<section id="_1_6_normalizing_vectors">
<title>1.6 Normalizing Vectors</title>
<simpara>Calculating the magnitude of a vector is only the beginning.  The magnitude function opens the door to many possibilities, the first of which is <emphasis role="strong"><emphasis>normalization</emphasis></emphasis>.  Normalizing refers to the process of making something “standard” or, well, “normal.”  In the case of vectors, let’s assume for the moment that a standard vector has a length of one.  To normalize a vector, therefore, is to take a vector of any length and, keeping it pointing in the same direction, change its length to one, turning it into what is called a <emphasis role="strong"><emphasis>unit vector</emphasis></emphasis>.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_17-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_17-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The ability to quickly access the unit vector is useful since it describes a vector’s direction without regard to length, and we’ll see this come in handy once we start to work with forces in Chapter 2.</simpara>
<simpara>For any given vector <emphasis role="strong"><phrase role="vector">u</phrase></emphasis>, its unit vector (written as û) is calculated as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>var]*û*</emphasis></emphasis> = <emphasis role="strong"><phrase role="vector">u</phrase></emphasis> / || [vector]*u*￼||
</simpara>
</listitem>
</itemizedlist>
<simpara>In other words, to normalize a vector, simply divide each component by its magnitude.  This is pretty intuitive.  Say a vector is of length 5.  Well, 5 divided by 5 is 1.  So looking at our right triangle, we then need to scale the hypotenuse down by dividing by 5.   In that process the sides shrink, divided by 5 as well.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_18-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_18-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In the PVector class, we therefore write our normalization function as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">void normalize() {
  float m = mag();
  div(m);
}</programlisting>
<simpara>Of course, there’s one small issue.  What if the magnitude of the vector is zero?  We can’t divide by zero!   Some quick error checking will fix that right up:</simpara>
<programlisting language="java" linenumbering="unnumbered">void normalize() {
 float m = mag();
 if (m != 0) {
   div(m);
 }
}</programlisting>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_19-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_19-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<section id="_example_1_6_normalizing_a_vector">
<title>Example 1-6: Normalizing a vector</title>
<programlisting language="java" linenumbering="unnumbered">void draw() {
  background(255);

  PVector mouse = new PVector(mouseX,mouseY);
  PVector center = new PVector(width/2,height/2);
  mouse.sub(center);

  // In this example, after the vector is normalized it is multiplied by 50 so that it is viewable onscreen. Note that no matter where the mouse is, the vector will have the same length (50) due to the normalization process.
  mouse.normalize();
  mouse.mult(50);
  translate(width/2,height/2);
  line(0,0,mouse.x,mouse.y);

}</programlisting>
</section>
</section>
<section id="_1_7_vector_motion_velocity">
<title>1.7 Vector Motion: Velocity</title>
<simpara>Why should we care?  Yes, all this vector math stuff sounds like something we should know about, but why exactly?  How will it actually help us write code?   The truth of the matter is that we need to have some patience.  The awesomeness of using the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class will take some time to fully come to light.  This is actually quite common when first learning a new data structure.   For example, when you first learn about an array, it might seem like much more work to use an array than to just have several variables stand for multiple things.   But that plan quickly breaks down when you need a hundred, or a thousand, or ten thousand things.  The same can be true for <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>.  What might seem like more work now will pay off later, and pay off quite nicely.  And you don’t have to wait too long, as your reward will come in the next chapter.</simpara>
<simpara>For now, however, we want to focus on simplicity.  What does it mean to program motion using vectors?   We’ve seen the beginning of this in Example 1.2 <emphasis role="strong"><emphasis>[REF]</emphasis></emphasis>: the bouncing ball.   An object on screen has a location (where it is at any given moment) as well as a velocity (instructions for how it should move from one moment to the next).   Velocity is added to location:</simpara>
<programlisting language="java" linenumbering="unnumbered">location.add(velocity);</programlisting>
<simpara>And then we draw the object at that location:</simpara>
<programlisting language="java" linenumbering="unnumbered">ellipse(location.x,location.y,16,16);</programlisting>
<simpara>This is Motion 101.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Add velocity to location</emphasis></emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>Draw object at location</emphasis></emphasis>
</simpara>
</listitem>
</orderedlist>
<simpara>In the bouncing ball example, all of this code happened in Processing’s main tab, within <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>.   What we want to do now is move towards encapsulating all of the logic for motion inside of a <emphasis role="strong"><emphasis>class</emphasis></emphasis>. This way, we can create a foundation for programming moving objects in Processing.    In <emphasis role="strong"><emphasis>[REF]</emphasis></emphasis> Section  section I.2 of the introduction, “The Random Walker Class,” we briefly reviewed the basics of object-oriented-programming (“OOP”).   Beyond that short introduction, this book assumes experience with objects and classes in Processing.   If you need a refresher, I encourage you to check out the online OOP Processing tutorial: <ulink url="http://processing.org/learning/tutorials/objects/">Processing objects tutorial</ulink>.</simpara>
<simpara>In this case, we’re going to create a generic <emphasis>Mover</emphasis> class, a class to describe a thing moving around the screen.  And so we must consider the following two questions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<emphasis role="strong"><emphasis>What data does a Mover have?</emphasis></emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong"><emphasis>What functionality does a Mover have?</emphasis></emphasis>
</simpara>
</listitem>
</orderedlist>
<simpara>Our “Motion 101” algorithm tells us the answers to these questions.  A Mover object has two pieces of data: location and velocity, two PVector objects.</simpara>
<programlisting language="java" linenumbering="unnumbered">class Mover {

  PVector location;
  PVector velocity;</programlisting>
<simpara>Its functionality is just about as simple.  The Mover needs to move and it needs to be seen.  We’ll implement these as functions named <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> and <emphasis role="strong"><phrase role="function">display()</phrase></emphasis>.  <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> is where we’ll put all of our motion logic code and <emphasis role="strong"><phrase role="function">display()</phrase></emphasis> is where we will draw the object.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void update() {
    // The Mover moves.
    location.add(velocity);
  }

  void display() {
    stroke(0);
    fill(175);
    // The Mover is displayed.
    ellipse(location.x,location.y,16,16);
  }

}</programlisting>
<simpara>We’ve forgotten one crucial item, however: the object’s <emphasis role="strong"><emphasis>constructor</emphasis></emphasis>.  The constructor is a special function inside of a class that creates the instance of the object itself. It is where you give instructions on how to set up the object.  It always has the same name as the class and is called by invoking the <emphasis role="strong"><emphasis>new</emphasis></emphasis> operator: “Mover <emphasis role="strong"><phrase role="var">m</phrase></emphasis> = new <emphasis role="strong"><phrase role="function">Mover( );</phrase></emphasis> ”.</simpara>
<simpara>In our case, let’s arbitrarily decide to initialize our mover object by giving it a random location and a random velocity.</simpara>
<programlisting language="java" linenumbering="unnumbered">  Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(random(-2,2),random(-2,2));
  }</programlisting>
<simpara>If object-oriented programming is at all new to you, one aspect here may seem a bit confusing.  After all, we spent the beginning of this chapter discussing the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class.  The <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class is the template for making the object “location” and the object “velocity”.  So what are they doing inside of yet another object, the Mover object?   In fact, this is just about the most normal thing ever.  An object is simply something that holds data (and functionality).  That data can be numbers (integers, floats, etc.) or other objects!  We’ll see this over and over again in this book.   For example, in Chapter 4 <emphasis role="strong"><emphasis>[REF]</emphasis></emphasis>, we’ll write a class to describe a system of particles.  That “ParticleSystem” object will have as its data a list of Particle objects. . .and each Particle object will have as its data several PVector objects!</simpara>
<simpara>Let’s finish off the Mover class by incorporating a function to determine what the object should do when it reaches the edge of the window.  For now let’s do something simple, and just have it wrap around the edges.</simpara>
<programlisting language="java" linenumbering="unnumbered">  void checkEdges() {

    // When it reaches one edge, set location to the other.
    if (location.x &gt; width) {
      location.x = 0;
    } else if (location.x &lt; 0) {
      location.x = width;
    }

    if (location.y &gt; height) {
      location.y = 0;
    } else if (location.y &lt; 0) {
      location.y = height;
    }

  }</programlisting>
<simpara>Now that the Mover class is finished, we can look at what we need to do in our main program.  We first declare a Mover object:</simpara>
<programlisting language="java" linenumbering="unnumbered">Mover mover;</programlisting>
<simpara>Then initialize the mover in <emphasis role="strong"><phrase role="function">setup()</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">mover = new Mover();</programlisting>
<simpara>and call the appropriate functions in <emphasis role="strong"><phrase role="function">draw()</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">mover.update();
mover.checkEdges();
mover.display();</programlisting>
<simpara>Here is the entire example for reference:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_20-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_20-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<section id="_example_1_7_motion_101_velocity">
<title>Example 1.7: Motion 101 (velocity)</title>
<programlisting language="java" linenumbering="unnumbered">Mover mover;      // Declare Mover object.

void setup() {
  size(200,200);
  smooth();
  background(255);
  mover = new Mover();  // Create Mover object.
}

void draw() {
  background(255);

  mover.update();   // Call functions on Mover object.
  mover.checkEdges();
  mover.display();
}

class Mover {

  PVector location;   // Our object has two PVectors: location and velocity.
  PVector velocity;

  Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(random(-2,2),random(-2,2));
  }

  void update() {
    location.add(velocity); // Motion 101: Location changes by velocity.
  }

  void display() {
    stroke(0);
    fill(175);
    ellipse(location.x,location.y,16,16);
  }

  void checkEdges() {
    if (location.x &gt; width) {
      location.x = 0;
    } else if (location.x &lt; 0) {
      location.x = width;
    }

    if (location.y &gt; height) {
      location.y = 0;
    } else if (location.y &lt; 0) {
      location.y = height;
    }
  }
}</programlisting>
</section>
</section>
<section id="_1_8_vector_motion_acceleration">
<title>1.8 Vector Motion: Acceleration</title>
<simpara>OK. At this point, we should feel comfortable with two things: (1) what a <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> is and (2) how we use <emphasis role="strong"><emphasis>PVectors</emphasis></emphasis> inside of an object to keep track of its location and movement.  This is an excellent first step and deserves a mild round of applause.   Before standing ovations and screaming fans, however, we need to make one more, somewhat larger, step forward.   After all, watching the Motion 101 example is fairly boring—the circle never speeds up, never slows down, and never turns.  For more interesting motion, for motion that appears in the real world around us, we need to add one more <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> to our class—<emphasis role="strong"><emphasis>acceleration</emphasis></emphasis>.</simpara>
<simpara>The strict definition of acceleration we’re using here is: the rate of <emphasis>change of velocity</emphasis>.  Let’s think about that definition for a moment.  Is this a new concept?  Not really.  Velocity is defined as <emphasis>the rate of change of location</emphasis>.  In essence, we are developing a “trickle down” effect.  Acceleration affects velocity, which in turn affects location (for some brief foreshadowing, this point will become even more crucial in the next chapter when we see how forces affect acceleration, which affects velocity, which affects location.)  In code, this reads:</simpara>
<programlisting language="java" linenumbering="unnumbered">velocity.add(acceleration);
location.add(velocity);</programlisting>
<simpara>As an exercise, from this point forward, let’s make a rule for ourselves.  Let’s write every example in the rest of this book without ever touching the value of velocity and location (except to initialize them).  In other words, our goal now for programming motion is as follows—come up with an algorithm for how we calculate acceleration and let the trickle-down effect work its magic.   (In truth, you’ll find reasons to break this rule, but it’s important to illustrate the principles behind our motion algorithm.)  And so we need to come up with some ways to calculate acceleration:</simpara>
<simpara>*ACCELERATION ALGORITHMS!</simpara>
<simpara>1) A constant acceleration
2) A totally random acceleration
3) Acceleration towards the mouse*</simpara>
<simpara>Algorithm #1, a constant acceleration, is not particularly interesting, but it is the simplest and will help us begin incorporating acceleration into our code.   The first thing we need to do is add another <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> to the Mover class:</simpara>
<programlisting language="java" linenumbering="unnumbered">class Mover {

  PVector location;
  PVector velocity;
  // A new PVector for acceleration
  PVector acceleration;</programlisting>
<simpara>And incorporate acceleration into the <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> function:</simpara>
<programlisting language="java" linenumbering="unnumbered"> void update() {
    // Our motion algorithm is now two lines of code!
    velocity.add(acceleration);
    location.add(velocity);
  }</programlisting>
<simpara>We’re almost done.  The only missing piece is initialization in the constructor.</simpara>
<programlisting language="java" linenumbering="unnumbered"> Mover() {</programlisting>
<simpara>Let’s start the mover object in the middle of the window. . .</simpara>
<programlisting language="java" linenumbering="unnumbered"> location = new PVector(width/2,height/2);</programlisting>
<orderedlist numeration="arabic">
<listitem>
<simpara>
. . with an initial velocity of zero.
</simpara>
</listitem>
</orderedlist>
<programlisting language="java" linenumbering="unnumbered"> velocity = new PVector(0,0);</programlisting>
<simpara>This means that when the sketch starts, the object is at rest.  We don’t have to worry about velocity anymore as we are controlling the object’s motion entirely with acceleration.  Speaking of which, according to Algorithm #1, our first sketch involves constant acceleration.  So let’s pick a value.</simpara>
<programlisting language="java" linenumbering="unnumbered">    acceleration = new PVector(-0.001,0.01);
  }</programlisting>
<simpara>Maybe you’re thinking, “Gosh, those values seem awfully small!”   That’s right, they are quite tiny.  It’s important to realize that our acceleration values (measured in pixels) accumulate over time in the velocity, about thirty times per second depending on our sketch’s frame rate.   And so to keep the magnitude of the velocity vector within a reasonable range, our acceleration values should remain quite small.   We can also help this cause by incorporating the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> function <emphasis role="strong"><phrase role="function">limit()</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">// The limit() function constrains the magnitude of a vector.
velocity.limit(10);</programlisting>
<simpara>This translates to the following:</simpara>
<simpara><emphasis>What is the magnitude of velocity?  If it’s less than 10, no worries; just leave it as is.  If it’s more than 10, however, reduce it to 10!</emphasis></simpara>
<example>
<title>Exercise 1-4</title>
<simpara>Write the <emphasis role="strong"><phrase role="function">limit()</phrase></emphasis> function for the PVector class.</simpara>
<simpara>void limit(float max) {
    if (<emphasis><emphasis></emphasis>_</emphasis> &gt; <emphasis><emphasis></emphasis>_</emphasis>) {
      <emphasis><emphasis></emphasis></emphasis><emphasis><emphasis>();
      </emphasis>_</emphasis>(max);
    }
  }</simpara>
</example>
<simpara>Let’s take a look at the changes to the Mover class, complete with <emphasis role="strong"><phrase role="function">acceleration</phrase></emphasis> and <emphasis role="strong"><phrase role="function">limit()</phrase></emphasis>.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_21-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_21-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<section id="_example_1_8_motion_101_velocity_and_constant_acceleration">
<title>Example 1.8: Motion 101 (velocity and constant acceleration)</title>
<programlisting language="java" linenumbering="unnumbered">￼class Mover {

  PVector location;
  PVector velocity;
  PVector acceleration; // Acceleration is the key!
  float topspeed;     // The variable, topspeed, will limit
           the magnitude of velocity.

  Mover() {
    location = new PVector(width/2,height/2);
    velocity = new PVector(0,0);
    acceleration = new PVector(-0.001,0.01);
    topspeed = 10;
  }

  void update() {
    velocity.add(acceleration); // Velocity changes by acceleration
    velocity.limit(topspeed);      and is limited by topspeed.
    location.add(velocity);
  }

  // display() is the same

  // checkEdges() is the same

}</programlisting>
<example>
<title>Exercise 1-4</title>
<simpara>Create a simulation of a car (or runner) that accelerates when you press the up key and brakes when you press the down key.</simpara>
</example>
<simpara>Now to Algorithm #2,“a totally random acceleration.”  In this case, instead of initializing acceleration in the object’s constructor, we want to pick a new acceleration each cycle, i.e. each time <emphasis role="strong"><phrase role="function">update()</phrase></emphasis> is called.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_22-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_22-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section id="_example_1_9_motion_101_velocity_and_random_acceleration">
<title>Example 1.9: Motion 101 (velocity and random acceleration)</title>
<programlisting language="java" linenumbering="unnumbered">  void update() {

    acceleration = new PVector(random(-1,1),random(-1,1));
    acceleration.normalize();

    velocity.add(acceleration);
    velocity.limit(topspeed);
    location.add(velocity);
  }</programlisting>
<simpara>While normalizing acceleration is not entirely necessary, it does prove useful, as it standardizes the magnitude of the vector, allowing us to try different things. Such as:</simpara>
<simpara>(a) scaling the acceleration to a constant value</simpara>
<programlisting language="java" linenumbering="unnumbered">acceleration = new PVector(random(-1,1),random(-1,1));
acceleration.normalize();
*acceleration.mult(0.5);*</programlisting>
<simpara>(b) scaling the acceleration to a random value</simpara>
<programlisting language="java" linenumbering="unnumbered">acceleration = new PVector(random(-1,1),random(-1,1));
acceleration.normalize();
*acceleration.mult(random(2));*</programlisting>
<simpara>While this may seem like an obvious point, it’s crucial to understand that acceleration does not merely refer to the <emphasis>speeding up</emphasis> or <emphasis>slowing down</emphasis> of a moving object, but rather <emphasis>any change</emphasis> in velocity in either magnitude or direction.   Acceleration is used to steer an object, and we’ll see this again and again in future chapters as we begin to program objects that make decisions about how to move about the screen.</simpara>
<example>
<title>Exercise 1-5</title>
<simpara>Referring back to section I.6 of the Introduction <emphasis role="strong">[REF]</emphasis>, implement acceleration according to Perlin noise.</simpara>
</example>
</section>
</section>
<section id="_1_9_static_vs_non_static_functions">
<title>1.9 Static vs. Non-Static Functions</title>
<simpara>Before we get to acceleration Algorithm #3 (accelerate towards the mouse), we need to cover one more rather important aspect of working with vectors and the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class: the difference between using <emphasis role="strong">static</emphasis> methods and <emphasis role="strong">non-static</emphasis> methods.</simpara>
<simpara>Forgetting about vectors for a moment, take a look at the following code:</simpara>
<programlisting language="java" linenumbering="unnumbered">float x = 0;
float y = 5;

x = x + y;</programlisting>
<simpara>Pretty simple, right?  <emphasis role="strong"><phrase role="var">x</phrase></emphasis> has the value of 0, we add <emphasis role="strong"><phrase role="var">y</phrase></emphasis> to it, and now <emphasis role="strong"><phrase role="var">x</phrase></emphasis> is equal to 5.  We could write the corresponding code pretty easily based on what we’ve learned about <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>.</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector v = new PVector(0,0);
PVector u = new PVector(4,5);
v.add(u);</programlisting>
<simpara>The vector <emphasis role="strong"><phrase role="var">v</phrase></emphasis> has the value of (0,0), we add <emphasis role="strong"><phrase role="var">u</phrase></emphasis> to it, and now <emphasis role="strong"><phrase role="var">v</phrase></emphasis> is equal to (4,5).  Easy, right?</simpara>
<simpara>OK, let’s take a look at another example of some simple floating point math:</simpara>
<programlisting language="java" linenumbering="unnumbered">float x = 0;
float y = 5;

float z = x + y;</programlisting>
<simpara><emphasis role="strong"><phrase role="var">x</phrase></emphasis> has the value of 0, we add <emphasis role="strong"><phrase role="var">y</phrase></emphasis> to it, and store the result in a new variable <emphasis role="strong"><phrase role="var">z</phrase></emphasis>.   The value of <emphasis role="strong"><phrase role="var">x</phrase></emphasis> does not change in this example (neither does <emphasis role="strong"><phrase role="var">y</phrase></emphasis>)!  This may seem like a trivial point, and one that is quite intuitive when it comes to mathematical operations with floats.   However, it’s not so obvious with mathematical operations in <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>).  Let’s try to write the code based on what we know so far.</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector v = new PVector(0,0);
PVector u = new PVector(4,5);
// Don’t be fooled; this is incorrect!!!
[line-through]*PVector w = v.add(u);*</programlisting>
<simpara>The above might seem like a good guess, but it’s just not the way the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> class works.   If we look at the definition of <emphasis role="strong"><phrase role="function">add()</phrase></emphasis> . . .</simpara>
<programlisting language="java" linenumbering="unnumbered">void add(PVector v) {
    x = x + v.x;
    y = y + v.y;
 }</programlisting>
<orderedlist numeration="arabic">
<listitem>
<simpara>
. . we see that this code does not accomplish our goal.  First, it does not return a new <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> (the return type is “void”) and second, it changes the value of the <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> upon which it is called.  In order to add two PVector objects together and return the result as a new PVector, we must use the <emphasis role="strong"><phrase role="function">static add()</phrase></emphasis> function.
</simpara>
</listitem>
</orderedlist>
<simpara>Functions that we call from the class name itself (rather than from a speciﬁc object instance) are known as <emphasis role="strong">static</emphasis> functions.   Here are two examples of function calls that assume two PVector objects, <emphasis role="strong"><phrase role="var">v</phrase></emphasis> and <emphasis role="strong"><phrase role="var">u</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Static: called from the class name.
PVector.add(v,u);
// Not static: called from an object instance.
v.add(u);</programlisting>
<simpara>Since you can’t write static functions yourself in Processing, you might not have encountered them before.  <emphasis role="strong"><phrase role="class">PVector*’s static functions allow us to perform generic mathematical operations on [class]*PVector</phrase></emphasis> objects without having to adjust the value of one of the input <emphasis role="strong"><emphasis>PVectors</emphasis></emphasis>.  Let’s look at how we might write the static version of <emphasis role="strong"><phrase role="function">add()</phrase></emphasis>:</simpara>
<programlisting language="java" linenumbering="unnumbered">  // The static version of add allows us to add two PVectors together and assign the result to a new PVector while leaving the original PVectors (v and u) intact.
  static PVector add(PVector v1, PVector v2) {
    PVector v3 = new PVector(v1.x + v2.x, v1.y + v2.y);
    return v3;
  }</programlisting>
<simpara>There are several differences here:</simpara>
<itemizedlist>
<listitem>
<simpara>
The function is labeled as <emphasis role="strong"><emphasis>static</emphasis></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
The function does not have a <emphasis role="strong"><emphasis>void</emphasis></emphasis> return type, but rather returns a <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
The function creates a new PVector (v3) and returns the sum of the components of <emphasis role="strong"><phrase role="var">v1</phrase></emphasis> and <emphasis role="strong"><phrase role="var">v2</phrase></emphasis> in that new PVector.
</simpara>
</listitem>
</itemizedlist>
<simpara>When you call a static function, instead of referencing an actual object instance, you simply reference the name of the class itself.</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector v = new PVector(0,0);
PVector u = new PVector(4,5);
[line-through]*PVector w = v.add(u);*
*PVector w = PVector.add(v,u);*</programlisting>
<simpara>The PVector class has static versions of <emphasis role="strong"><phrase role="function">add()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">sub()</phrase></emphasis>, <emphasis role="strong"><phrase role="function">mult()</phrase></emphasis>, and <emphasis role="strong"><phrase role="function">div()</phrase></emphasis>.</simpara>
<example>
<title>Exercise 1-6</title>
<simpara>Translate the following pseudocode to code using static or non-static functions where appropriate.</simpara>
<itemizedlist>
<listitem>
<simpara>
The PVector [var]*v equals (1,5)
</simpara>
</listitem>
<listitem>
<simpara>
The PVector <emphasis role="strong"><phrase role="var">u</phrase></emphasis> equals <emphasis role="strong"><phrase role="var">v</phrase></emphasis> multiplied by 2.
</simpara>
</listitem>
<listitem>
<simpara>
The PVector <emphasis role="strong"><phrase role="var">w</phrase></emphasis> equals <emphasis role="strong"><phrase role="var">v</phrase></emphasis> minus <emphasis role="strong"><phrase role="var">u</phrase></emphasis>.
</simpara>
</listitem>
<listitem>
<simpara>
Divide the PVector w by 3.
</simpara>
</listitem>
</itemizedlist>
<simpara>PVector <emphasis role="strong"><phrase role="var">v</phrase></emphasis> = new PVector(1,5);
PVector <emphasis role="strong"><phrase role="var">u</phrase></emphasis> = <emphasis><emphasis></emphasis></emphasis><emphasis>.</emphasis><emphasis><emphasis>(</emphasis>,<emphasis>);
PVector <emphasis role="strong"><phrase role="var">w</phrase></emphasis> = </emphasis></emphasis><emphasis><emphasis></emphasis>.<emphasis></emphasis></emphasis>(<emphasis>,</emphasis>);
<emphasis><emphasis></emphasis></emphasis><emphasis>_</emphasis>;</simpara>
</example>
</section>
<section id="_1_10_interactivity_with_acceleration">
<title>1.10 Interactivity with acceleration</title>
<simpara>To finish out this chapter, let’s try something a bit more complex and a great deal more useful.  We’ll dynamically calculate an object’s acceleration according to a rule, acceleration Algorithm #3 —“the object accelerates towards the mouse.”</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_23-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_23-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Anytime we want to calculate a vector based on a rule or a formula, we need to compute two things: <emphasis role="strong"><emphasis>magnitude</emphasis></emphasis> and <emphasis role="strong"><emphasis>direction</emphasis></emphasis>.  Let’s start with direction.  We know the acceleration vector should point from the object’s location towards the mouse location.  Let’s say the object is located at the point (<emphasis role="strong"><phrase role="var">x</phrase></emphasis>,<emphasis role="strong"><phrase role="var">y</phrase></emphasis>) and the mouse at (<emphasis role="strong"><phrase role="var">mouseX</phrase></emphasis>,<emphasis role="strong"><phrase role="var">mouseY</phrase></emphasis>).</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_24-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_24-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>As illustrated in the above diagram, we see that we can get a vector (<emphasis role="strong"><phrase role="var">dx</phrase></emphasis>,<emphasis role="strong"><phrase role="var">dy</phrase></emphasis>) by subtracting the object’s location from the mouse’s location.</simpara>
<simpara><emphasis role="strong">[var]*dx</emphasis> = <emphasis role="strong"><phrase role="var">mouseX</phrase></emphasis> - <emphasis role="strong"><phrase role="var">x<emphasis role="strong">
*[var]*dy</phrase></emphasis> = <emphasis role="strong"><phrase role="var">mouseY</phrase></emphasis> - [var]*y</emphasis></simpara>
<simpara>Let’s rewrite the above using <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> syntax.   Assuming we are in the Mover class and thus have access to the object’s location <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis>, we then have:</simpara>
<programlisting language="java" linenumbering="unnumbered">PVector mouse = new PVector(mouseX,mouseY);
// Look! We’re using the static reference to sub() because we want a new PVector pointing from one point to another.
PVector dir = PVector.sub(mouse,location);</programlisting>
<simpara>We now have a <emphasis role="strong"><phrase role="class">PVector</phrase></emphasis> that points from the mover’s location all the way to the mouse.  If the object were to actually accelerate using that vector, it would appear instantaneously at the mouse location.  This does not make for good animation, of course, and what we want to do now is decide how quickly that object should accelerate toward the mouse.</simpara>
<simpara>In order to set the magnitude (whatever it may be) of our acceleration PVector, we must first <emphasis><emphasis></emphasis>__</emphasis> that direction vector.  That’s right, you said it.  <emphasis role="strong"><emphasis>Normalize</emphasis></emphasis>.   If we can shrink the vector down to its unit vector (of length one) then we have a vector that tells us the direction and can easily be scaled to any value.   One multiplied by anything equals anything.</simpara>
<programlisting language="java" linenumbering="unnumbered">float anything = ?????
dir.normalize();
dir.mult(anything);</programlisting>
<simpara>To summarize, we take the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Calculate a vector that points from the object to the target location (mouse).
</simpara>
</listitem>
<listitem>
<simpara>
Normalize that vector (reducing its length to 1)
</simpara>
</listitem>
<listitem>
<simpara>
Scale that vector to an appropriate value (by multiplying it by some value)
</simpara>
</listitem>
<listitem>
<simpara>
Assign that vector to acceleration
</simpara>
</listitem>
</orderedlist>
<simpara>And here are those steps in the <emphasis role="strong"><emphasis>update()</emphasis></emphasis> function itself:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_25-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_25-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<programlisting language="java" linenumbering="unnumbered"> void update() {

    PVector mouse = new PVector(mouseX,mouseY);
    // Step 1: Direction
    PVector dir = PVector.sub(mouse,location);

    // Step 2: Normalize
    dir.normalize();

    // Step 3: Scale
    dir.mult(0.5);

    // Step 4: Accelerate
    acceleration = dir;

    velocity.add(acceleration);
    velocity.limit(topspeed);
    location.add(velocity);

  }</programlisting>
<simpara>You may be wondering why the circle doesn’t stop when it reaches the target.  It’s important to note that the object moving has no knowledge about trying to stop at a destination; it only knows where the destination is and tries to go there as quickly as possible. Going as quickly as possible means it will inevitably overshoot the location and have to turn around, again going as quickly as possible towards the destination, overshooting it again, and so on, and so forth.   Stay tuned; in later chapters we’ll learn how to program an object to “arrive” at a location (slow down on approach).</simpara>
<example>
<title>Exercise 1-7</title>
<simpara>This example is remarkably close to the concept of gravitational attraction (in which the object is attracted to the mouse location).  Gravitational attraction will be covered in more detail in the next chapter. However, one thing missing here is that the strength of gravity (magnitude of acceleration) is inversely proportional to distance.  This means that the closer the object is to the mouse, the faster it accelerates.   Try implementing the above example with a variable magnitude of acceleration, stronger when it is either closer or farther away.</simpara>
</example>
<simpara>Let’s see what this example would look like with an array of Mover objects (rather than just one).</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="imgs/chapter01_26-01.png" />
  </imageobject>
  <textobject><phrase>imgs/chapter01_26-01.png</phrase></textobject>
</mediaobject>
</informalfigure>
<section id="_example_1_10_accelerating_towards_mouse">
<title>Example 1.10: Accelerating towards mouse</title>
<programlisting language="java" linenumbering="unnumbered">// An array of objects
Mover[] movers = new Mover[20];

void setup() {
  size(200,200);
  smooth();
  background(255);
  for (int i = 0; i &lt; movers.length; i++) {
    // Initialize each object in the array.
    movers[i] = new Mover();
  }
}

void draw() {
  background(255);

  for (int i = 0; i &lt; movers.length; i++) {
    // Calling functions on all the objects in the array.
    movers[i].update();
    movers[i].checkEdges();
    movers[i].display();
  }
}

class Mover {
  // Our algorithm for calculating acceleration:
  // find vector pointing towards mouse
  // normalize
  // scale
  // set to acceleration
  PVector location;
  PVector velocity;
  PVector acceleration;
  float topspeed;

  Mover() {
    location = new PVector(random(width),random(height));
    velocity = new PVector(0,0);
    topspeed = 4;
  }

  void update() {

    PVector mouse = new PVector(mouseX,mouseY);
    PVector dir = PVector.sub(mouse,location);
    dir.normalize();
    dir.mult(0.5);
    acceleration = dir;

    // Motion 101! Velocity changes by acceleration.  Location changes by velocity.
    velocity.add(acceleration);
    velocity.limit(topspeed);
    location.add(velocity);
  }

  void display() {
    stroke(0);
    fill(175);
    ellipse(location.x,location.y,16,16);
  }

  void checkEdges() {

    if (location.x &gt; width) {
      location.x = 0;
    } else if (location.x &lt; 0) {
      location.x = width;
    }

    if (location.y &gt; height) {
      location.y = 0;
    }  else if (location.y &lt; 0) {
      location.y = height;
    }
  }
}</programlisting>
<tip>
<title>Ecosystem Project:</title>
<simpara>As mentioned in the preface, one way to use this book is to build a single project over the course of reading it, incorporating elements from each chapter one step at a time.  We’ll follow the development of an example project throughout this book—an “ecosystem” simulation.  Imagine a population of computational creatures swimming around a digital pond, interacting with each other according to various rules.</simpara>
<simpara>Step 1 Exercise:</simpara>
<simpara>Develop a set of rules for simulating the real-world behavior of a creature, such as a nervous fly, swimming fish, hopping bunny, slithering snake, etc.  Can you control the object’s motion by only manipulating the acceleration?  Try to give the creature a personality through its behavior (rather than through its visual design.)</simpara>
</tip>
</section>
</section>
</article>
